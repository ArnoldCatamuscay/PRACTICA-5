/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "gestionPersonal.h"
#include "gestionNotificaciones.h"
#include <string.h>

datos_personal vectorDeUsuarios[6];
int consultaVector_username(char* username);
int consultaVector_id(int id);
int posUsuario=0;

bool_t *
registrarpersonal_1_svc(datos_personal *argp, struct svc_req *rqstp)
{
	static bool_t  result;

	printf("\n --------Invocando a Registrar Personal\n");
	if (posUsuario<6)
	{
		vectorDeUsuarios[posUsuario]=*argp;
		result = TRUE;
		posUsuario++;
		printf("\n --------Personal Registrado\n");
	}
	else
    {
		printf("\n --------Cantidad maxima de registros alcanzada\n");
		result=FALSE;
	}

	return &result;
}

datos_personal *
consultarpersonal_1_svc(int *argp, struct svc_req *rqstp)
{
	static datos_personal  result;
    result.id = 0;
    int pos = consultaVector_id(*argp);
    printf("\n --------Invocando a Consultar Personal\n");
    if (pos!=-1){
        result = vectorDeUsuarios[pos];
        printf("\n --------Personal Encontrado\n");
    }

	return &result;
}

bool_t *
abrirsesion_1_svc(datos_credencial *argp, struct svc_req *rqstp)
{
	static bool_t  result;
    char * host = "127.0.0.1";
    CLIENT *clnt;
    
	bool_t  *result_1;
	char * enviarnotificacion_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, gestion_notificaciones, gestion_notificaciones_version, "udp");
	if (clnt == NULL) {
        printf("\nERROR UDP EN SERVIDOR 1\n");
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
    printf("\n --------Invocando a Abrir Sesion\n");
    char* nombre_completo =  malloc(sizeof(char)*30);
    char* ocupacion = malloc(sizeof(char)*20);
    if(strcmp(argp->usuario, "ingesis")==0 && strcmp(argp->clave, "ingesis")==0){
        strcpy(enviarnotificacion_1_arg, "Bienvenido ingesis");
    }else{
        int pos = consultaVector_username(argp->usuario);
        
        if(pos!=-1){
            
            strcpy(nombre_completo, vectorDeUsuarios[pos].nombreCompleto);
            strcpy(ocupacion, vectorDeUsuarios[pos].ocupacion);
            char mensaje[200];
            strcpy(mensaje," ");
            strcat(mensaje, "El personal ");
            strcat(mensaje, nombre_completo);
            strcat(mensaje, " y ocupacion ");
            strcat(mensaje, ocupacion);
            strcat(mensaje, " est√° autorizado para ingresar al sistema.");
            enviarnotificacion_1_arg = mensaje;
        }else{
            enviarnotificacion_1_arg = "";
        }
    }
    
	result_1 = enviarnotificacion_1(&enviarnotificacion_1_arg, clnt);
	if (result_1 == (bool_t *) NULL) {
		clnt_perror (clnt, "call Enviar Notificacion failed");
	}else if(*result_1==TRUE){
        result = TRUE;
    } else{
        result = FALSE;
    }
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */

	return &result;
}

/**
 * retorna la posicon del usuario en el vector de usuarios, buscando por el id
 * si no se encuentra retorna -1
 */
int consultaVector_id(int p_id){
	int resultado=-1;
	int i ;
	for (i=0 ;  i<6 ; i++){
		if (vectorDeUsuarios[i].id == p_id){
			resultado=i;
			break;
		}	
	}
	return resultado;
}
/**
 * retorna la posicon del usuario en el vector de usuarios, buscando por el username
 * si no se encuentra retorna -1
 */
int consultaVector_username(char* p_username){
	int resultado=-1;
	int i ;
	for (i=0 ;  i<6 ; i++){
		if (strcmp(vectorDeUsuarios[i].usuario,p_username)==0){
            if(strcmp(vectorDeUsuarios[i].usuario,"")==0){
                resultado=-1;
            }
			resultado=i;
			break;
		}	
	}
	return resultado;
}
